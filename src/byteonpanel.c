/* byteonpanel.c generated by valac 0.40.17, the Vala compiler
 * generated from byteonpanel.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>
#include <glib/gstdio.h>
#include <cairo.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <config.h>
#include <gdk-pixbuf/gdk-pixbuf.h>


#define TYPE_BYTE_STAT (byte_stat_get_type ())
typedef struct _ByteStat ByteStat;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_IFACE (iface_get_type ())
#define IFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IFACE, IFace))
#define IFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IFACE, IFaceClass))
#define IS_IFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IFACE))
#define IS_IFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IFACE))
#define IFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IFACE, IFaceClass))

typedef struct _IFace IFace;
typedef struct _IFaceClass IFaceClass;
typedef struct _IFacePrivate IFacePrivate;
enum  {
	IFACE_0_PROPERTY,
	IFACE_ISUP_PROPERTY,
	IFACE_NUM_PROPERTIES
};
static GParamSpec* iface_properties[IFACE_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _byte_stat_free0(var) ((var == NULL) ? NULL : (var = (byte_stat_free (var), NULL)))

#define TYPE_STATUS_ICON_IF (status_icon_if_get_type ())
#define STATUS_ICON_IF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_STATUS_ICON_IF, StatusIconIF))
#define STATUS_ICON_IF_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_STATUS_ICON_IF, StatusIconIFClass))
#define IS_STATUS_ICON_IF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_STATUS_ICON_IF))
#define IS_STATUS_ICON_IF_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_STATUS_ICON_IF))
#define STATUS_ICON_IF_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_STATUS_ICON_IF, StatusIconIFClass))

typedef struct _StatusIconIF StatusIconIF;
typedef struct _StatusIconIFClass StatusIconIFClass;
typedef struct _StatusIconIFPrivate StatusIconIFPrivate;

#define TYPE_APPLICATION (application_get_type ())
#define APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APPLICATION, Application))
#define APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APPLICATION, ApplicationClass))
#define IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APPLICATION))
#define IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APPLICATION))
#define APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APPLICATION, ApplicationClass))

typedef struct _Application Application;
typedef struct _ApplicationClass ApplicationClass;
enum  {
	STATUS_ICON_IF_0_PROPERTY,
	STATUS_ICON_IF_NUM_PROPERTIES
};
static GParamSpec* status_icon_if_properties[STATUS_ICON_IF_NUM_PROPERTIES];
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))

#define STATUS_ICON_IF_TYPE_TRANS_SPEED (status_icon_if_trans_speed_get_type ())
typedef struct _StatusIconIFTransSpeed StatusIconIFTransSpeed;
typedef struct _ApplicationPrivate ApplicationPrivate;
enum  {
	APPLICATION_0_PROPERTY,
	APPLICATION_NUM_PROPERTIES
};
static GParamSpec* application_properties[APPLICATION_NUM_PROPERTIES];
#define _g_tree_unref0(var) ((var == NULL) ? NULL : (var = (g_tree_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

struct _ByteStat {
	gdouble time_stamp;
	guint64 rx_total;
	gdouble rx_speed;
	guint64 tx_total;
	gdouble tx_speed;
	gdouble total_speed;
};

struct _IFace {
	GObject parent_instance;
	IFacePrivate * priv;
	gchar* iface_id;
	guint maxlen;
	GQueue* flow_queue;
};

struct _IFaceClass {
	GObjectClass parent_class;
};

struct _IFacePrivate {
	gchar* iface_path;
	gchar* rx_path;
	gchar* tx_path;
	gchar* operstate_path;
	GTimeVal tval;
};

struct _StatusIconIF {
	GObject parent_instance;
	StatusIconIFPrivate * priv;
	IFace* iface;
	gfloat portion;
	gfloat portion_low;
	gfloat rate_low;
	guint update_timeout;
	guint update_scale_timeout;
};

struct _StatusIconIFClass {
	GObjectClass parent_class;
};

struct _StatusIconIFPrivate {
	Application* app;
	cairo_t* ctx;
	cairo_surface_t* surface;
	gdouble scale;
	GtkStatusIcon* statusicon;
	GtkMenu* menu;
	guint update_id;
	guint update_scale_id;
	gint margin;
	guint* color_step;
	gint color_step_length1;
	gint _color_step_size_;
	gchar** rx_color_strings;
	gint rx_color_strings_length1;
	gint _rx_color_strings_size_;
	gchar** tx_color_strings;
	gint tx_color_strings_length1;
	gint _tx_color_strings_size_;
	GdkRGBA* rx_colors;
	gint rx_colors_length1;
	gint _rx_colors_size_;
	GdkRGBA* tx_colors;
	gint tx_colors_length1;
	gint _tx_colors_size_;
};

struct _StatusIconIFTransSpeed {
	gdouble* rx_list;
	gint rx_list_length1;
	gint _rx_list_size_;
	gdouble* tx_list;
	gint tx_list_length1;
	gint _tx_list_size_;
};

struct _Application {
	GObject parent_instance;
	ApplicationPrivate * priv;
};

struct _ApplicationClass {
	GObjectClass parent_class;
};

struct _ApplicationPrivate {
	GTree* iface_map;
	guint iface_update_timeout;
	gulong about_response_id;
};

struct _Block1Data {
	int _ref_count_;
	Application* self;
	gchar** key2remove;
	gint key2remove_length1;
	gint _key2remove_size_;
};


static gpointer iface_parent_class = NULL;
static gpointer status_icon_if_parent_class = NULL;
static gpointer application_parent_class = NULL;

#define fdelta 1E-9
#define MAX_SLOT ((guint) 48)
#define MIN_STATUS_ICON_SIZE 16
#define SYS_NET_PATH "/sys/class/net"
GType byte_stat_get_type (void) G_GNUC_CONST;
ByteStat* byte_stat_dup (const ByteStat* self);
void byte_stat_free (ByteStat* self);
gchar* humanize_number (gdouble num,
                        gfloat step,
                        const gchar* unit_string);
GType iface_get_type (void) G_GNUC_CONST;
#define IFACE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_IFACE, IFacePrivate))
static void _byte_stat_free0_ (gpointer var);
static inline void _g_queue_free__byte_stat_free0_ (GQueue* self);
IFace* iface_new (const gchar* if_name);
IFace* iface_construct (GType object_type,
                        const gchar* if_name);
void iface_update (IFace* self);
gboolean iface_get_isup (IFace* self);
static void iface_finalize (GObject * obj);
static void _vala_iface_get_property (GObject * object,
                               guint property_id,
                               GValue * value,
                               GParamSpec * pspec);
GType status_icon_if_get_type (void) G_GNUC_CONST;
GType application_get_type (void) G_GNUC_CONST;
#define STATUS_ICON_IF_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_STATUS_ICON_IF, StatusIconIFPrivate))
StatusIconIF* status_icon_if_new (Application* app_obj,
                                  IFace* iface_obj);
StatusIconIF* status_icon_if_construct (GType object_type,
                                        Application* app_obj,
                                        IFace* iface_obj);
static void _vala_array_add1 (GdkRGBA* * array,
                       int* length,
                       int* size,
                       const GdkRGBA* value);
static void _vala_array_add2 (GdkRGBA* * array,
                       int* length,
                       int* size,
                       const GdkRGBA* value);
static void status_icon_if_setup_icon (StatusIconIF* self);
static gboolean status_icon_if_on_status_icon_size_changed (StatusIconIF* self,
                                                     GtkStatusIcon* sicon,
                                                     gint size);
static gboolean _status_icon_if_on_status_icon_size_changed_gtk_status_icon_size_changed (GtkStatusIcon* _sender,
                                                                                   gint size,
                                                                                   gpointer self);
static void status_icon_if_setup_menu (StatusIconIF* self);
gboolean status_icon_if_update_scale (StatusIconIF* self);
static gboolean _status_icon_if_update_scale_gsource_func (gpointer self);
static void status_icon_if_on_popup_menu (StatusIconIF* self,
                                   guint button,
                                   guint atime);
void application_on_about_dialog_show (Application* self,
                                       GtkAction* act);
static void _application_on_about_dialog_show_gtk_action_activate (GtkAction* _sender,
                                                            gpointer self);
void status_icon_if_on_quit (StatusIconIF* self,
                             GtkAction* act);
static void _status_icon_if_on_quit_gtk_action_activate (GtkAction* _sender,
                                                  gpointer self);
static void _status_icon_if_on_popup_menu_gtk_status_icon_popup_menu (GtkStatusIcon* _sender,
                                                               guint button,
                                                               guint activate_time,
                                                               gpointer self);
static gchar* status_icon_if_make_tooltip (StatusIconIF* self);
static gdouble status_icon_if_max_total_speed (StatusIconIF* self,
                                        GQueue* somed);
static GType status_icon_if_trans_speed_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static StatusIconIFTransSpeed* status_icon_if_trans_speed_dup (const StatusIconIFTransSpeed* self);
static void status_icon_if_trans_speed_free (StatusIconIFTransSpeed* self);
static void status_icon_if_trans_speed_copy (const StatusIconIFTransSpeed* self,
                                      StatusIconIFTransSpeed* dest);
static void status_icon_if_trans_speed_destroy (StatusIconIFTransSpeed* self);
static void status_icon_if_get_speed (StatusIconIF* self,
                               gdouble max_speed,
                               StatusIconIFTransSpeed* result);
static gdouble* _vala_array_dup1 (gdouble* self,
                           int length);
static gdouble* _vala_array_dup2 (gdouble* self,
                           int length);
static gint status_icon_if_color_index_by_speed (StatusIconIF* self,
                                          gdouble current_speed);
gboolean status_icon_if_update (StatusIconIF* self);
static gdouble* _vala_array_dup3 (gdouble* self,
                           int length);
static gdouble* _vala_array_dup4 (gdouble* self,
                           int length);
void status_icon_if_start_timers (StatusIconIF* self);
static gboolean _status_icon_if_update_gsource_func (gpointer self);
void application_quit (Application* self);
void status_icon_if_on_destroy (StatusIconIF* self);
static gdouble* _vala_array_dup5 (gdouble* self,
                           int length);
static gdouble* _vala_array_dup6 (gdouble* self,
                           int length);
static void status_icon_if_finalize (GObject * obj);
#define APPLICATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_APPLICATION, ApplicationPrivate))
static Application* application_new (void);
static Application* application_construct (GType object_type);
static gint __lambda4_ (Application* self,
                 const gchar* a,
                 const gchar* b);
static gint ___lambda4__gcompare_data_func (gconstpointer a,
                                     gconstpointer b,
                                     gpointer self);
static void _g_object_unref_gdestroy_notify (void* data);
static gboolean application_update_iface (Application* self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean __lambda5_ (Block1Data* _data1_,
                     const gchar* k,
                     StatusIconIF* v);
static void _vala_array_add3 (gchar** * array,
                       int* length,
                       int* size,
                       gchar* value);
static gboolean ___lambda5__gtraverse_func (gconstpointer key,
                                     gconstpointer value,
                                     gpointer self);
static void __lambda6_ (Application* self,
                 GtkDialog* a,
                 gint b);
static void ___lambda6__gtk_dialog_response (GtkDialog* _sender,
                                      gint response_id,
                                      gpointer self);
void application_start (Application* self);
static gboolean _application_update_iface_gsource_func (gpointer self);
gint application_main (gchar** args,
                       int args_length1);
static void application_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);


ByteStat*
byte_stat_dup (const ByteStat* self)
{
	ByteStat* dup;
	dup = g_new0 (ByteStat, 1);
	memcpy (dup, self, sizeof (ByteStat));
	return dup;
}


void
byte_stat_free (ByteStat* self)
{
	g_free (self);
}


GType
byte_stat_get_type (void)
{
	static volatile gsize byte_stat_type_id__volatile = 0;
	if (g_once_init_enter (&byte_stat_type_id__volatile)) {
		GType byte_stat_type_id;
		byte_stat_type_id = g_boxed_type_register_static ("ByteStat", (GBoxedCopyFunc) byte_stat_dup, (GBoxedFreeFunc) byte_stat_free);
		g_once_init_leave (&byte_stat_type_id__volatile, byte_stat_type_id);
	}
	return byte_stat_type_id__volatile;
}


gchar*
humanize_number (gdouble num,
                 gfloat step,
                 const gchar* unit_string)
{
	gchar* result = NULL;
	gchar** ends = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar** _tmp9_;
	gint ends_length1;
	gint _ends_size_;
	gchar* the_end = NULL;
	gchar** _tmp10_;
	gint _tmp10__length1;
	gchar** _tmp11_;
	gint _tmp11__length1;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gchar** _tmp14_;
	gint _tmp14__length1;
	const gchar* _tmp18_;
	gchar* _tmp19_;
	g_return_val_if_fail (unit_string != NULL, NULL);
	_tmp0_ = g_strdup ("");
	_tmp1_ = g_strdup ("K");
	_tmp2_ = g_strdup ("M");
	_tmp3_ = g_strdup ("G");
	_tmp4_ = g_strdup ("T");
	_tmp5_ = g_strdup ("P");
	_tmp6_ = g_strdup ("E");
	_tmp7_ = g_strdup ("Z");
	_tmp8_ = g_strdup ("Y");
	_tmp9_ = g_new0 (gchar*, 9 + 1);
	_tmp9_[0] = _tmp0_;
	_tmp9_[1] = _tmp1_;
	_tmp9_[2] = _tmp2_;
	_tmp9_[3] = _tmp3_;
	_tmp9_[4] = _tmp4_;
	_tmp9_[5] = _tmp5_;
	_tmp9_[6] = _tmp6_;
	_tmp9_[7] = _tmp7_;
	_tmp9_[8] = _tmp8_;
	ends = _tmp9_;
	ends_length1 = 9;
	_ends_size_ = ends_length1;
	_tmp10_ = ends;
	_tmp10__length1 = ends_length1;
	_tmp11_ = ends;
	_tmp11__length1 = ends_length1;
	_tmp12_ = _tmp10_[_tmp11__length1 - 1];
	_tmp13_ = g_strdup (_tmp12_);
	the_end = _tmp13_;
	num = num * 8;
	_tmp14_ = ends;
	_tmp14__length1 = ends_length1;
	{
		gchar** i_collection = NULL;
		gint i_collection_length1 = 0;
		gint _i_collection_size_ = 0;
		gint i_it = 0;
		i_collection = _tmp14_;
		i_collection_length1 = _tmp14__length1;
		for (i_it = 0; i_it < i_collection_length1; i_it = i_it + 1) {
			gchar* _tmp15_;
			gchar* i = NULL;
			_tmp15_ = g_strdup (i_collection[i_it]);
			i = _tmp15_;
			{
				if (num < ((gdouble) step)) {
					const gchar* _tmp16_;
					gchar* _tmp17_;
					_tmp16_ = i;
					_tmp17_ = g_strdup (_tmp16_);
					_g_free0 (the_end);
					the_end = _tmp17_;
					_g_free0 (i);
					break;
				}
				num = num / step;
				_g_free0 (i);
			}
		}
	}
	_tmp18_ = the_end;
	_tmp19_ = g_strdup_printf ("%.2f%s%s", num, _tmp18_, unit_string);
	result = _tmp19_;
	_g_free0 (the_end);
	ends = (_vala_array_free (ends, ends_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static void
_byte_stat_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (byte_stat_free (var), NULL));
}


static inline void
_g_queue_free__byte_stat_free0_ (GQueue* self)
{
	g_queue_free_full (self, (GDestroyNotify) _byte_stat_free0_);
}


IFace*
iface_construct (GType object_type,
                 const gchar* if_name)
{
	IFace * self = NULL;
	gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	GQueue* _tmp9_;
	g_return_val_if_fail (if_name != NULL, NULL);
	self = (IFace*) g_object_new (object_type, NULL);
	_tmp0_ = g_strdup (if_name);
	_g_free0 (self->iface_id);
	self->iface_id = _tmp0_;
	_tmp1_ = self->iface_id;
	_tmp2_ = g_build_filename (SYS_NET_PATH, _tmp1_, NULL);
	_g_free0 (self->priv->iface_path);
	self->priv->iface_path = _tmp2_;
	_tmp3_ = self->priv->iface_path;
	_tmp4_ = g_build_filename (_tmp3_, "statistics", "rx_bytes", NULL);
	_g_free0 (self->priv->rx_path);
	self->priv->rx_path = _tmp4_;
	_tmp5_ = self->priv->iface_path;
	_tmp6_ = g_build_filename (_tmp5_, "statistics", "tx_bytes", NULL);
	_g_free0 (self->priv->tx_path);
	self->priv->tx_path = _tmp6_;
	_tmp7_ = self->priv->iface_path;
	_tmp8_ = g_build_filename (_tmp7_, "operstate", NULL);
	_g_free0 (self->priv->operstate_path);
	self->priv->operstate_path = _tmp8_;
	_tmp9_ = g_queue_new ();
	(self->flow_queue == NULL) ? NULL : (self->flow_queue = (_g_queue_free__byte_stat_free0_ (self->flow_queue), NULL));
	self->flow_queue = _tmp9_;
	g_get_current_time (&self->priv->tval);
	return self;
}


IFace*
iface_new (const gchar* if_name)
{
	return iface_construct (TYPE_IFACE, if_name);
}


static guint64
uint64_parse (const gchar* str)
{
	guint64 result = 0ULL;
	g_return_val_if_fail (str != NULL, 0ULL);
	result = g_ascii_strtoull (str, NULL, (guint) 0);
	return result;
}


static gpointer
_byte_stat_dup0 (gpointer self)
{
	return self ? byte_stat_dup (self) : NULL;
}


void
iface_update (IFace* self)
{
	gdouble time_stamp = 0.0;
	gdouble rx_rate = 0.0;
	gdouble tx_rate = 0.0;
	gdouble _tmp0_;
	guint64 rx = 0ULL;
	guint64 tx = 0ULL;
	GTimeVal _tmp24_;
	glong _tmp25_;
	GTimeVal _tmp26_;
	glong _tmp27_;
	ByteStat* last_stat = NULL;
	GQueue* _tmp28_;
	gconstpointer _tmp29_;
	ByteStat* _tmp30_;
	GQueue* _tmp31_;
	guint _tmp32_;
	ByteStat item = {0};
	gdouble _tmp45_;
	guint64 _tmp46_;
	gdouble _tmp47_;
	guint64 _tmp48_;
	gdouble _tmp49_;
	gdouble _tmp50_;
	gdouble _tmp51_;
	ByteStat _tmp52_ = {0};
	GQueue* _tmp53_;
	ByteStat _tmp54_;
	ByteStat* _tmp55_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	tx_rate = (gdouble) 0;
	_tmp0_ = tx_rate;
	rx_rate = _tmp0_;
	{
		guint8* rx_buf = NULL;
		guint8* _tmp1_;
		gint rx_buf_length1;
		gint _rx_buf_size_;
		guint8* tx_buf = NULL;
		guint8* _tmp2_;
		gint tx_buf_length1;
		gint _tx_buf_size_;
		gsize rlen = 0UL;
		GFile* fd = NULL;
		const gchar* _tmp3_;
		GFile* _tmp4_;
		GFileInputStream* rx_stream = NULL;
		GFile* _tmp5_;
		GFileInputStream* _tmp6_;
		const gchar* _tmp7_;
		GFile* _tmp8_;
		GFileInputStream* tx_stream = NULL;
		GFile* _tmp9_;
		GFileInputStream* _tmp10_;
		GFileInputStream* _tmp11_;
		guint8* _tmp12_;
		gint _tmp12__length1;
		gsize _tmp13_ = 0UL;
		GFileInputStream* _tmp14_;
		guint8* _tmp15_;
		gint _tmp15__length1;
		gsize _tmp16_ = 0UL;
		GFileInputStream* _tmp17_;
		GFileInputStream* _tmp18_;
		guint8* _tmp19_;
		gint _tmp19__length1;
		guint8* _tmp20_;
		gint _tmp20__length1;
		_tmp1_ = g_new0 (guint8, 64);
		rx_buf = _tmp1_;
		rx_buf_length1 = 64;
		_rx_buf_size_ = rx_buf_length1;
		_tmp2_ = g_new0 (guint8, 64);
		tx_buf = _tmp2_;
		tx_buf_length1 = 64;
		_tx_buf_size_ = tx_buf_length1;
		_tmp3_ = self->priv->rx_path;
		_tmp4_ = g_file_new_for_path (_tmp3_);
		fd = _tmp4_;
		_tmp5_ = fd;
		_tmp6_ = g_file_read (_tmp5_, NULL, &_inner_error0_);
		rx_stream = _tmp6_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp7_ = self->priv->tx_path;
		_tmp8_ = g_file_new_for_path (_tmp7_);
		_g_object_unref0 (fd);
		fd = _tmp8_;
		_tmp9_ = fd;
		_tmp10_ = g_file_read (_tmp9_, NULL, &_inner_error0_);
		tx_stream = _tmp10_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		g_get_current_time (&self->priv->tval);
		_tmp11_ = rx_stream;
		_tmp12_ = rx_buf;
		_tmp12__length1 = rx_buf_length1;
		g_input_stream_read_all ((GInputStream*) _tmp11_, _tmp12_, (gsize) _tmp12__length1, &_tmp13_, NULL, &_inner_error0_);
		rlen = _tmp13_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp14_ = tx_stream;
		_tmp15_ = tx_buf;
		_tmp15__length1 = tx_buf_length1;
		g_input_stream_read_all ((GInputStream*) _tmp14_, _tmp15_, (gsize) _tmp15__length1, &_tmp16_, NULL, &_inner_error0_);
		rlen = _tmp16_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp17_ = rx_stream;
		g_input_stream_close ((GInputStream*) _tmp17_, NULL, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp18_ = tx_stream;
		g_input_stream_close ((GInputStream*) _tmp18_, NULL, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (tx_stream);
			_g_object_unref0 (rx_stream);
			_g_object_unref0 (fd);
			tx_buf = (g_free (tx_buf), NULL);
			rx_buf = (g_free (rx_buf), NULL);
			goto __catch0_g_error;
		}
		_tmp19_ = rx_buf;
		_tmp19__length1 = rx_buf_length1;
		rx = uint64_parse ((const gchar*) _tmp19_);
		_tmp20_ = tx_buf;
		_tmp20__length1 = tx_buf_length1;
		tx = uint64_parse ((const gchar*) _tmp20_);
		_g_object_unref0 (tx_stream);
		_g_object_unref0 (rx_stream);
		_g_object_unref0 (fd);
		tx_buf = (g_free (tx_buf), NULL);
		rx_buf = (g_free (rx_buf), NULL);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp21_;
		GError* _tmp22_;
		const gchar* _tmp23_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp21_ = stderr;
		_tmp22_ = e;
		_tmp23_ = _tmp22_->message;
		fprintf (_tmp21_, "Error: %s\n", _tmp23_);
		_g_error_free0 (e);
		return;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp24_ = self->priv->tval;
	_tmp25_ = _tmp24_.tv_sec;
	_tmp26_ = self->priv->tval;
	_tmp27_ = _tmp26_.tv_usec;
	time_stamp = _tmp25_ + (_tmp27_ / 1000000.0);
	_tmp28_ = self->flow_queue;
	_tmp29_ = g_queue_peek_tail (_tmp28_);
	_tmp30_ = _byte_stat_dup0 ((ByteStat*) _tmp29_);
	last_stat = _tmp30_;
	_tmp31_ = self->flow_queue;
	_tmp32_ = _tmp31_->length;
	if (_tmp32_ > ((guint) 1)) {
		gdouble laps = 0.0;
		gdouble _tmp33_;
		ByteStat* _tmp34_;
		gdouble _tmp35_;
		gdouble _tmp36_;
		_tmp33_ = time_stamp;
		_tmp34_ = last_stat;
		_tmp35_ = (*_tmp34_).time_stamp;
		laps = _tmp33_ - _tmp35_;
		_tmp36_ = laps;
		if (_tmp36_ == 0.0) {
			rx_rate = 0.0;
			tx_rate = 0.0;
		} else {
			guint64 _tmp37_;
			ByteStat* _tmp38_;
			guint64 _tmp39_;
			gdouble _tmp40_;
			guint64 _tmp41_;
			ByteStat* _tmp42_;
			guint64 _tmp43_;
			gdouble _tmp44_;
			_tmp37_ = rx;
			_tmp38_ = last_stat;
			_tmp39_ = (*_tmp38_).rx_total;
			_tmp40_ = laps;
			rx_rate = (_tmp37_ - _tmp39_) / _tmp40_;
			_tmp41_ = tx;
			_tmp42_ = last_stat;
			_tmp43_ = (*_tmp42_).tx_total;
			_tmp44_ = laps;
			tx_rate = (_tmp41_ - _tmp43_) / _tmp44_;
		}
	}
	_tmp45_ = time_stamp;
	_tmp46_ = rx;
	_tmp47_ = rx_rate;
	_tmp48_ = tx;
	_tmp49_ = tx_rate;
	_tmp50_ = rx_rate;
	_tmp51_ = tx_rate;
	_tmp52_.time_stamp = _tmp45_;
	_tmp52_.rx_total = _tmp46_;
	_tmp52_.rx_speed = _tmp47_;
	_tmp52_.tx_total = _tmp48_;
	_tmp52_.tx_speed = _tmp49_;
	_tmp52_.total_speed = _tmp50_ + _tmp51_;
	item = _tmp52_;
	_tmp53_ = self->flow_queue;
	_tmp54_ = item;
	_tmp55_ = _byte_stat_dup0 (&_tmp54_);
	g_queue_push_tail (_tmp53_, _tmp55_);
	while (TRUE) {
		GQueue* _tmp56_;
		guint _tmp57_;
		guint _tmp58_;
		GQueue* _tmp59_;
		gpointer _tmp60_;
		ByteStat* _tmp61_;
		_tmp56_ = self->flow_queue;
		_tmp57_ = _tmp56_->length;
		_tmp58_ = self->maxlen;
		if (!(_tmp57_ > _tmp58_)) {
			break;
		}
		_tmp59_ = self->flow_queue;
		_tmp60_ = g_queue_pop_head (_tmp59_);
		_tmp61_ = (ByteStat*) _tmp60_;
		_byte_stat_free0 (_tmp61_);
	}
	_byte_stat_free0 (last_stat);
}


static gchar*
string_strip (const gchar* self)
{
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


gboolean
iface_get_isup (IFace* self)
{
	gboolean result;
	gchar* text = NULL;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gboolean _tmp12_;
	GError* _inner_error0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		_tmp0_ = self->priv->operstate_path;
		g_file_get_contents (_tmp0_, &_tmp1_, NULL, &_inner_error0_);
		_g_free0 (text);
		text = _tmp1_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gboolean _tmp2_ = FALSE;
			if (_inner_error0_->domain == G_FILE_ERROR) {
				goto __catch1_g_file_error;
			}
			_g_free0 (text);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp2_;
		}
	}
	goto __finally1;
	__catch1_g_file_error:
	{
		GError* e = NULL;
		FILE* _tmp3_;
		GError* _tmp4_;
		const gchar* _tmp5_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp3_ = stderr;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		fprintf (_tmp3_, "Error: %s\n", _tmp5_);
		result = FALSE;
		_g_error_free0 (e);
		_g_free0 (text);
		return result;
	}
	__finally1:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp6_ = FALSE;
		_g_free0 (text);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp6_;
	}
	_tmp7_ = text;
	_tmp8_ = string_strip (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = g_utf8_strdown (_tmp9_, (gssize) -1);
	_tmp11_ = _tmp10_;
	_tmp12_ = g_strcmp0 (_tmp11_, "up") == 0;
	_g_free0 (_tmp11_);
	_g_free0 (_tmp9_);
	result = _tmp12_;
	_g_free0 (text);
	return result;
}


static void
iface_class_init (IFaceClass * klass)
{
	iface_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (IFacePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_iface_get_property;
	G_OBJECT_CLASS (klass)->finalize = iface_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), IFACE_ISUP_PROPERTY, iface_properties[IFACE_ISUP_PROPERTY] = g_param_spec_boolean ("isup", "isup", "isup", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}


static void
iface_instance_init (IFace * self)
{
	self->priv = IFACE_GET_PRIVATE (self);
	self->maxlen = MAX_SLOT;
}


static void
iface_finalize (GObject * obj)
{
	IFace * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_IFACE, IFace);
	_g_free0 (self->priv->iface_path);
	_g_free0 (self->priv->rx_path);
	_g_free0 (self->priv->tx_path);
	_g_free0 (self->priv->operstate_path);
	_g_free0 (self->iface_id);
	(self->flow_queue == NULL) ? NULL : (self->flow_queue = (_g_queue_free__byte_stat_free0_ (self->flow_queue), NULL));
	G_OBJECT_CLASS (iface_parent_class)->finalize (obj);
}


GType
iface_get_type (void)
{
	static volatile gsize iface_type_id__volatile = 0;
	if (g_once_init_enter (&iface_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IFaceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) iface_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IFace), 0, (GInstanceInitFunc) iface_instance_init, NULL };
		GType iface_type_id;
		iface_type_id = g_type_register_static (G_TYPE_OBJECT, "IFace", &g_define_type_info, 0);
		g_once_init_leave (&iface_type_id__volatile, iface_type_id);
	}
	return iface_type_id__volatile;
}


static void
_vala_iface_get_property (GObject * object,
                          guint property_id,
                          GValue * value,
                          GParamSpec * pspec)
{
	IFace * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_IFACE, IFace);
	switch (property_id) {
		case IFACE_ISUP_PROPERTY:
		g_value_set_boolean (value, iface_get_isup (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static void
_vala_array_add1 (GdkRGBA* * array,
                  int* length,
                  int* size,
                  const GdkRGBA* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GdkRGBA, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void
_vala_array_add2 (GdkRGBA* * array,
                  int* length,
                  int* size,
                  const GdkRGBA* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GdkRGBA, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


StatusIconIF*
status_icon_if_construct (GType object_type,
                          Application* app_obj,
                          IFace* iface_obj)
{
	StatusIconIF * self = NULL;
	Application* _tmp0_;
	IFace* _tmp1_;
	IFace* _tmp16_;
	guint _tmp17_;
	guint _tmp18_;
	g_return_val_if_fail (app_obj != NULL, NULL);
	g_return_val_if_fail (iface_obj != NULL, NULL);
	self = (StatusIconIF*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (app_obj);
	_g_object_unref0 (self->priv->app);
	self->priv->app = _tmp0_;
	_tmp1_ = _g_object_ref0 (iface_obj);
	_g_object_unref0 (self->iface);
	self->iface = _tmp1_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_;
				guint* _tmp5_;
				gint _tmp5__length1;
				GdkRGBA color = {0};
				gchar** _tmp6_;
				gint _tmp6__length1;
				gint _tmp7_;
				const gchar* _tmp8_;
				GdkRGBA* _tmp9_;
				gint _tmp9__length1;
				GdkRGBA _tmp10_;
				gchar** _tmp11_;
				gint _tmp11__length1;
				gint _tmp12_;
				const gchar* _tmp13_;
				GdkRGBA* _tmp14_;
				gint _tmp14__length1;
				GdkRGBA _tmp15_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = self->priv->color_step;
				_tmp5__length1 = self->priv->color_step_length1;
				if (!(_tmp4_ < _tmp5__length1)) {
					break;
				}
				memset (&color, 0, sizeof (GdkRGBA));
				_tmp6_ = self->priv->rx_color_strings;
				_tmp6__length1 = self->priv->rx_color_strings_length1;
				_tmp7_ = i;
				_tmp8_ = _tmp6_[_tmp7_];
				gdk_rgba_parse (&color, _tmp8_);
				_tmp9_ = self->priv->rx_colors;
				_tmp9__length1 = self->priv->rx_colors_length1;
				_tmp10_ = color;
				_vala_array_add1 (&self->priv->rx_colors, &self->priv->rx_colors_length1, &self->priv->_rx_colors_size_, &_tmp10_);
				memset (&color, 0, sizeof (GdkRGBA));
				_tmp11_ = self->priv->tx_color_strings;
				_tmp11__length1 = self->priv->tx_color_strings_length1;
				_tmp12_ = i;
				_tmp13_ = _tmp11_[_tmp12_];
				gdk_rgba_parse (&color, _tmp13_);
				_tmp14_ = self->priv->tx_colors;
				_tmp14__length1 = self->priv->tx_colors_length1;
				_tmp15_ = color;
				_vala_array_add2 (&self->priv->tx_colors, &self->priv->tx_colors_length1, &self->priv->_tx_colors_size_, &_tmp15_);
			}
		}
	}
	status_icon_if_setup_icon (self);
	_tmp16_ = self->iface;
	_tmp17_ = _tmp16_->maxlen;
	_tmp18_ = self->update_timeout;
	self->update_scale_timeout = _tmp17_ * _tmp18_;
	return self;
}


StatusIconIF*
status_icon_if_new (Application* app_obj,
                    IFace* iface_obj)
{
	return status_icon_if_construct (TYPE_STATUS_ICON_IF, app_obj, iface_obj);
}


static gboolean
_status_icon_if_on_status_icon_size_changed_gtk_status_icon_size_changed (GtkStatusIcon* _sender,
                                                                          gint size,
                                                                          gpointer self)
{
	gboolean result;
	result = status_icon_if_on_status_icon_size_changed ((StatusIconIF*) self, _sender, size);
	return result;
}


static void
status_icon_if_setup_icon (StatusIconIF* self)
{
	GtkStatusIcon* _tmp0_;
	GtkStatusIcon* _tmp1_;
	GtkStatusIcon* _tmp2_;
	GtkStatusIcon* _tmp3_;
	GtkStatusIcon* _tmp4_;
	GtkStatusIcon* _tmp5_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_status_icon_new ();
	_g_object_unref0 (self->priv->statusicon);
	self->priv->statusicon = _tmp0_;
	_tmp1_ = self->priv->statusicon;
	gtk_status_icon_set_visible (_tmp1_, TRUE);
	_tmp2_ = self->priv->statusicon;
	gtk_status_icon_set_title (_tmp2_, PACKAGE_NAME);
	_tmp3_ = self->priv->statusicon;
	g_signal_connect_object (_tmp3_, "size-changed", (GCallback) _status_icon_if_on_status_icon_size_changed_gtk_status_icon_size_changed, self, 0);
	status_icon_if_setup_menu (self);
	_tmp4_ = self->priv->statusicon;
	_tmp5_ = self->priv->statusicon;
	status_icon_if_on_status_icon_size_changed (self, _tmp4_, gtk_status_icon_get_size (_tmp5_));
}


static gboolean
_status_icon_if_update_scale_gsource_func (gpointer self)
{
	gboolean result;
	result = status_icon_if_update_scale ((StatusIconIF*) self);
	return result;
}


static gboolean
status_icon_if_on_status_icon_size_changed (StatusIconIF* self,
                                            GtkStatusIcon* sicon,
                                            gint size)
{
	gboolean result = FALSE;
	gint hsize = 0;
	gint _tmp1_;
	cairo_surface_t* _tmp2_;
	cairo_surface_t* _tmp3_;
	cairo_t* _tmp4_;
	IFace* _tmp5_;
	guint _tmp6_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (sicon != NULL, FALSE);
	if (!gtk_status_icon_is_embedded (sicon)) {
		result = FALSE;
		return result;
	}
	hsize = size;
	if (size >= MIN_STATUS_ICON_SIZE) {
		gint _tmp0_;
		_tmp0_ = self->priv->margin;
		hsize = size - (_tmp0_ * 2);
	}
	_tmp1_ = hsize;
	_tmp2_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, size, _tmp1_);
	_cairo_surface_destroy0 (self->priv->surface);
	self->priv->surface = _tmp2_;
	_tmp3_ = self->priv->surface;
	_tmp4_ = cairo_create (_tmp3_);
	_cairo_destroy0 (self->priv->ctx);
	self->priv->ctx = _tmp4_;
	_tmp5_ = self->iface;
	_tmp6_ = _tmp5_->maxlen;
	if (((guint) size) < _tmp6_) {
		IFace* _tmp7_;
		IFace* _tmp8_;
		guint _tmp9_;
		guint _tmp10_;
		guint _tmp11_;
		guint _tmp13_;
		_tmp7_ = self->iface;
		_tmp7_->maxlen = (guint) size;
		_tmp8_ = self->iface;
		_tmp9_ = _tmp8_->maxlen;
		_tmp10_ = self->update_timeout;
		self->update_scale_timeout = _tmp9_ * _tmp10_;
		_tmp11_ = self->priv->update_scale_id;
		if (_tmp11_ > ((guint) 0)) {
			guint _tmp12_;
			_tmp12_ = self->priv->update_scale_id;
			g_source_remove (_tmp12_);
			self->priv->update_scale_id = (guint) -1;
		}
		_tmp13_ = self->update_scale_timeout;
		self->priv->update_scale_id = g_timeout_add_full (G_PRIORITY_DEFAULT, _tmp13_, _status_icon_if_update_scale_gsource_func, g_object_ref (self), g_object_unref);
	}
	result = TRUE;
	return result;
}


static void
status_icon_if_on_popup_menu (StatusIconIF* self,
                              guint button,
                              guint atime)
{
	GtkMenu* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->menu;
	gtk_menu_popup (_tmp0_, NULL, NULL, NULL, NULL, button, (guint32) atime);
}


static void
_application_on_about_dialog_show_gtk_action_activate (GtkAction* _sender,
                                                       gpointer self)
{
	application_on_about_dialog_show ((Application*) self, _sender);
}


static void
_status_icon_if_on_quit_gtk_action_activate (GtkAction* _sender,
                                             gpointer self)
{
	status_icon_if_on_quit ((StatusIconIF*) self, _sender);
}


static void
_status_icon_if_on_popup_menu_gtk_status_icon_popup_menu (GtkStatusIcon* _sender,
                                                          guint button,
                                                          guint activate_time,
                                                          gpointer self)
{
	status_icon_if_on_popup_menu ((StatusIconIF*) self, button, activate_time);
}


static void
status_icon_if_setup_menu (StatusIconIF* self)
{
	static const char ui_info[] = "\n" \
"            <ui>\n" \
"                <popup name=\"Popup\">\n" \
"                    <menuitem action=\"About\"/>\n" \
"                    <separator/>\n" \
"                    <menuitem action=\"Quit\"/>\n" \
"                </popup>\n" \
"            </ui>\n" \
"        ";
	GtkActionGroup* actions = NULL;
	GtkActionGroup* _tmp0_;
	GtkAction* action = NULL;
	GtkAction* _tmp1_;
	GtkAction* _tmp2_;
	Application* _tmp3_;
	GtkActionGroup* _tmp4_;
	GtkAction* _tmp5_;
	GtkAction* _tmp6_;
	GtkAction* _tmp7_;
	GtkActionGroup* _tmp8_;
	GtkAction* _tmp9_;
	GtkUIManager* ui = NULL;
	GtkUIManager* _tmp10_;
	GtkUIManager* _tmp11_;
	GtkActionGroup* _tmp12_;
	GtkUIManager* _tmp17_;
	GtkWidget* _tmp18_;
	GtkMenu* _tmp19_;
	GtkStatusIcon* _tmp20_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_action_group_new ("StatusIconPopup");
	actions = _tmp0_;
	_tmp1_ = gtk_action_new ("About", NULL, NULL, GTK_STOCK_ABOUT);
	_g_object_unref0 (action);
	action = _tmp1_;
	_tmp2_ = action;
	_tmp3_ = self->priv->app;
	g_signal_connect_object (_tmp2_, "activate", (GCallback) _application_on_about_dialog_show_gtk_action_activate, _tmp3_, 0);
	_tmp4_ = actions;
	_tmp5_ = action;
	gtk_action_group_add_action (_tmp4_, _tmp5_);
	_tmp6_ = gtk_action_new ("Quit", NULL, NULL, GTK_STOCK_QUIT);
	_g_object_unref0 (action);
	action = _tmp6_;
	_tmp7_ = action;
	g_signal_connect_object (_tmp7_, "activate", (GCallback) _status_icon_if_on_quit_gtk_action_activate, self, 0);
	_tmp8_ = actions;
	_tmp9_ = action;
	gtk_action_group_add_action (_tmp8_, _tmp9_);
	_tmp10_ = gtk_ui_manager_new ();
	ui = _tmp10_;
	_tmp11_ = ui;
	_tmp12_ = actions;
	gtk_ui_manager_insert_action_group (_tmp11_, _tmp12_, 0);
	{
		GtkUIManager* _tmp13_;
		_tmp13_ = ui;
		gtk_ui_manager_add_ui_from_string (_tmp13_, ui_info, (gssize) -1, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch2_g_error;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		FILE* _tmp14_;
		GError* _tmp15_;
		const gchar* _tmp16_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp14_ = stderr;
		_tmp15_ = e;
		_tmp16_ = _tmp15_->message;
		fprintf (_tmp14_, "Error: %s\n", _tmp16_);
		_g_error_free0 (e);
		_g_object_unref0 (ui);
		_g_object_unref0 (action);
		_g_object_unref0 (actions);
		return;
	}
	__finally2:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (ui);
		_g_object_unref0 (action);
		_g_object_unref0 (actions);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp17_ = ui;
	_tmp18_ = gtk_ui_manager_get_widget (_tmp17_, "/Popup");
	_tmp19_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp18_, gtk_menu_get_type ()) ? ((GtkMenu*) _tmp18_) : NULL);
	_g_object_unref0 (self->priv->menu);
	self->priv->menu = _tmp19_;
	_tmp20_ = self->priv->statusicon;
	g_signal_connect_object (_tmp20_, "popup-menu", (GCallback) _status_icon_if_on_popup_menu_gtk_status_icon_popup_menu, self, 0);
	_g_object_unref0 (ui);
	_g_object_unref0 (action);
	_g_object_unref0 (actions);
	return;
}


static gchar*
status_icon_if_make_tooltip (StatusIconIF* self)
{
	gchar* result = NULL;
	gdouble rx_av = 0.0;
	gdouble tx_av = 0.0;
	gdouble _tmp0_;
	ByteStat* last_stat = NULL;
	IFace* _tmp1_;
	GQueue* _tmp2_;
	gconstpointer _tmp3_;
	ByteStat* _tmp4_;
	ByteStat* first_stat = NULL;
	IFace* _tmp5_;
	GQueue* _tmp6_;
	gconstpointer _tmp7_;
	ByteStat* _tmp8_;
	IFace* _tmp9_;
	GQueue* _tmp10_;
	guint _tmp11_;
	gchar* rx_now = NULL;
	ByteStat* _tmp28_;
	gdouble _tmp29_;
	gchar* _tmp30_;
	gchar* tx_now = NULL;
	ByteStat* _tmp31_;
	gdouble _tmp32_;
	gchar* _tmp33_;
	gchar* rx_av_text = NULL;
	gdouble _tmp34_;
	gchar* _tmp35_;
	gchar* tx_av_text = NULL;
	gdouble _tmp36_;
	gchar* _tmp37_;
	gchar* txt = NULL;
	IFace* _tmp38_;
	const gchar* _tmp39_;
	gchar* _tmp40_;
	g_return_val_if_fail (self != NULL, NULL);
	tx_av = 0.0;
	_tmp0_ = tx_av;
	rx_av = _tmp0_;
	_tmp1_ = self->iface;
	_tmp2_ = _tmp1_->flow_queue;
	_tmp3_ = g_queue_peek_tail (_tmp2_);
	_tmp4_ = _byte_stat_dup0 ((ByteStat*) _tmp3_);
	last_stat = _tmp4_;
	_tmp5_ = self->iface;
	_tmp6_ = _tmp5_->flow_queue;
	_tmp7_ = g_queue_peek_head (_tmp6_);
	_tmp8_ = _byte_stat_dup0 ((ByteStat*) _tmp7_);
	first_stat = _tmp8_;
	_tmp9_ = self->iface;
	_tmp10_ = _tmp9_->flow_queue;
	_tmp11_ = _tmp10_->length;
	if (_tmp11_ > ((guint) 1)) {
		ByteStat* _tmp12_;
		guint64 _tmp13_;
		ByteStat* _tmp14_;
		guint64 _tmp15_;
		ByteStat* _tmp16_;
		gdouble _tmp17_;
		ByteStat* _tmp18_;
		gdouble _tmp19_;
		ByteStat* _tmp20_;
		guint64 _tmp21_;
		ByteStat* _tmp22_;
		guint64 _tmp23_;
		ByteStat* _tmp24_;
		gdouble _tmp25_;
		ByteStat* _tmp26_;
		gdouble _tmp27_;
		_tmp12_ = last_stat;
		_tmp13_ = (*_tmp12_).rx_total;
		_tmp14_ = first_stat;
		_tmp15_ = (*_tmp14_).rx_total;
		_tmp16_ = last_stat;
		_tmp17_ = (*_tmp16_).time_stamp;
		_tmp18_ = first_stat;
		_tmp19_ = (*_tmp18_).time_stamp;
		rx_av = (_tmp13_ - _tmp15_) / (_tmp17_ - _tmp19_);
		_tmp20_ = last_stat;
		_tmp21_ = (*_tmp20_).tx_total;
		_tmp22_ = first_stat;
		_tmp23_ = (*_tmp22_).tx_total;
		_tmp24_ = last_stat;
		_tmp25_ = (*_tmp24_).time_stamp;
		_tmp26_ = first_stat;
		_tmp27_ = (*_tmp26_).time_stamp;
		tx_av = (_tmp21_ - _tmp23_) / (_tmp25_ - _tmp27_);
	}
	_tmp28_ = last_stat;
	_tmp29_ = (*_tmp28_).rx_speed;
	_tmp30_ = humanize_number (_tmp29_, 1024.0f, "bps");
	rx_now = _tmp30_;
	_tmp31_ = last_stat;
	_tmp32_ = (*_tmp31_).tx_speed;
	_tmp33_ = humanize_number (_tmp32_, 1024.0f, "bps");
	tx_now = _tmp33_;
	_tmp34_ = rx_av;
	_tmp35_ = humanize_number (_tmp34_, 1024.0f, "bps");
	rx_av_text = _tmp35_;
	_tmp36_ = tx_av;
	_tmp37_ = humanize_number (_tmp36_, 1024.0f, "bps");
	tx_av_text = _tmp37_;
	_tmp38_ = self->iface;
	_tmp39_ = _tmp38_->iface_id;
	_tmp40_ = g_strdup_printf ("Interface: %s\nIn/Out(current): %s/%s\nIn/Out(average): %s/%s", _tmp39_, rx_now, tx_now, rx_av_text, tx_av_text);
	txt = _tmp40_;
	result = txt;
	_g_free0 (tx_av_text);
	_g_free0 (rx_av_text);
	_g_free0 (tx_now);
	_g_free0 (rx_now);
	_byte_stat_free0 (first_stat);
	_byte_stat_free0 (last_stat);
	return result;
}


static gdouble
status_icon_if_max_total_speed (StatusIconIF* self,
                                GQueue* somed)
{
	gdouble result = 0.0;
	gdouble a = 0.0;
	g_return_val_if_fail (self != NULL, 0.0);
	g_return_val_if_fail (somed != NULL, 0.0);
	a = DBL_MIN;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp2_;
				guint _tmp3_;
				ByteStat* b = NULL;
				gint _tmp4_;
				gconstpointer _tmp5_;
				ByteStat* _tmp6_;
				ByteStat* _tmp7_;
				gdouble _tmp8_;
				gdouble _tmp9_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = i;
				_tmp3_ = somed->length;
				if (!(((guint) _tmp2_) < _tmp3_)) {
					break;
				}
				_tmp4_ = i;
				_tmp5_ = g_queue_peek_nth (somed, (guint) _tmp4_);
				_tmp6_ = _byte_stat_dup0 ((ByteStat*) _tmp5_);
				b = _tmp6_;
				_tmp7_ = b;
				_tmp8_ = (*_tmp7_).total_speed;
				_tmp9_ = a;
				if (_tmp8_ > _tmp9_) {
					ByteStat* _tmp10_;
					gdouble _tmp11_;
					_tmp10_ = b;
					_tmp11_ = (*_tmp10_).total_speed;
					a = _tmp11_;
				}
				_byte_stat_free0 (b);
			}
		}
	}
	result = a;
	return result;
}


gboolean
status_icon_if_update_scale (StatusIconIF* self)
{
	gboolean result = FALSE;
	gint height = 0;
	cairo_surface_t* _tmp0_;
	gdouble total = 0.0;
	IFace* _tmp1_;
	GQueue* _tmp2_;
	gfloat port = 0.0F;
	gfloat _tmp3_;
	gdouble _tmp4_;
	gfloat _tmp5_;
	gdouble _tmp7_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->surface;
	height = cairo_image_surface_get_height (_tmp0_);
	_tmp1_ = self->iface;
	_tmp2_ = _tmp1_->flow_queue;
	total = status_icon_if_max_total_speed (self, _tmp2_);
	_tmp3_ = self->portion;
	port = _tmp3_;
	_tmp4_ = total;
	_tmp5_ = self->rate_low;
	if (_tmp4_ < ((gdouble) _tmp5_)) {
		gfloat _tmp6_;
		_tmp6_ = self->portion_low;
		port = _tmp6_;
	}
	_tmp7_ = total;
	if (_tmp7_ > fdelta) {
		gdouble lscale = 0.0;
		gint _tmp8_;
		gfloat _tmp9_;
		gdouble _tmp10_;
		gboolean _tmp11_ = FALSE;
		gboolean _tmp12_ = FALSE;
		gdouble _tmp13_;
		_tmp8_ = height;
		_tmp9_ = port;
		_tmp10_ = total;
		lscale = (_tmp8_ * _tmp9_) / _tmp10_;
		_tmp13_ = self->priv->scale;
		if (_tmp13_ < (-fdelta)) {
			_tmp12_ = TRUE;
		} else {
			gboolean _tmp14_ = FALSE;
			gdouble _tmp15_;
			_tmp15_ = self->priv->scale;
			if (_tmp15_ > fdelta) {
				gdouble _tmp16_;
				gdouble _tmp17_;
				gdouble _tmp18_;
				_tmp16_ = self->priv->scale;
				_tmp17_ = lscale;
				_tmp18_ = self->priv->scale;
				_tmp14_ = (fabs (_tmp16_ - _tmp17_) / _tmp18_) > 0.3;
			} else {
				_tmp14_ = FALSE;
			}
			_tmp12_ = _tmp14_;
		}
		if (_tmp12_) {
			_tmp11_ = TRUE;
		} else {
			gint _tmp19_;
			gdouble _tmp20_;
			gdouble _tmp21_;
			_tmp19_ = height;
			_tmp20_ = self->priv->scale;
			_tmp21_ = total;
			_tmp11_ = ((gdouble) _tmp19_) < (_tmp20_ * _tmp21_);
		}
		if (_tmp11_) {
			gdouble _tmp22_;
			_tmp22_ = lscale;
			self->priv->scale = _tmp22_;
		}
	}
	result = TRUE;
	return result;
}


static gdouble*
_vala_array_dup1 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}


static gdouble*
_vala_array_dup2 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}


static void
status_icon_if_get_speed (StatusIconIF* self,
                          gdouble max_speed,
                          StatusIconIFTransSpeed* result)
{
	gdouble* rx_list = NULL;
	IFace* _tmp0_;
	GQueue* _tmp1_;
	guint _tmp2_;
	gdouble* _tmp3_;
	gint rx_list_length1;
	gint _rx_list_size_;
	gdouble* tx_list = NULL;
	IFace* _tmp4_;
	GQueue* _tmp5_;
	guint _tmp6_;
	gdouble* _tmp7_;
	gint tx_list_length1;
	gint _tx_list_size_;
	gdouble _tmp8_;
	gdouble lscale = 0.0;
	gdouble _tmp9_;
	StatusIconIFTransSpeed ret = {0};
	gdouble* _tmp37_;
	gint _tmp37__length1;
	gdouble* _tmp38_;
	gint _tmp38__length1;
	gdouble* _tmp39_;
	gint _tmp39__length1;
	gdouble* _tmp40_;
	gint _tmp40__length1;
	StatusIconIFTransSpeed _tmp41_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = self->iface;
	_tmp1_ = _tmp0_->flow_queue;
	_tmp2_ = _tmp1_->length;
	_tmp3_ = g_new0 (gdouble, _tmp2_);
	rx_list = _tmp3_;
	rx_list_length1 = _tmp2_;
	_rx_list_size_ = rx_list_length1;
	_tmp4_ = self->iface;
	_tmp5_ = _tmp4_->flow_queue;
	_tmp6_ = _tmp5_->length;
	_tmp7_ = g_new0 (gdouble, _tmp6_);
	tx_list = _tmp7_;
	tx_list_length1 = _tmp6_;
	_tx_list_size_ = tx_list_length1;
	_tmp8_ = self->priv->scale;
	if (_tmp8_ < (-fdelta)) {
		status_icon_if_update_scale (self);
	}
	_tmp9_ = self->priv->scale;
	if (_tmp9_ < (-fdelta)) {
		lscale = 1.0;
	} else {
		gdouble _tmp10_;
		_tmp10_ = self->priv->scale;
		lscale = _tmp10_;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp11_ = FALSE;
			_tmp11_ = TRUE;
			while (TRUE) {
				gint _tmp13_;
				IFace* _tmp14_;
				GQueue* _tmp15_;
				guint _tmp16_;
				ByteStat* statn = NULL;
				IFace* _tmp17_;
				GQueue* _tmp18_;
				gint _tmp19_;
				gconstpointer _tmp20_;
				ByteStat* _tmp21_;
				gdouble rspeed = 0.0;
				ByteStat* _tmp22_;
				gdouble _tmp23_;
				gdouble _tmp24_;
				gdouble tspeed = 0.0;
				ByteStat* _tmp25_;
				gdouble _tmp26_;
				gdouble _tmp27_;
				gdouble _tmp28_;
				gdouble _tmp29_;
				if (!_tmp11_) {
					gint _tmp12_;
					_tmp12_ = i;
					i = _tmp12_ + 1;
				}
				_tmp11_ = FALSE;
				_tmp13_ = i;
				_tmp14_ = self->iface;
				_tmp15_ = _tmp14_->flow_queue;
				_tmp16_ = _tmp15_->length;
				if (!(((guint) _tmp13_) < _tmp16_)) {
					break;
				}
				_tmp17_ = self->iface;
				_tmp18_ = _tmp17_->flow_queue;
				_tmp19_ = i;
				_tmp20_ = g_queue_peek_nth (_tmp18_, (guint) _tmp19_);
				_tmp21_ = _byte_stat_dup0 ((ByteStat*) _tmp20_);
				statn = _tmp21_;
				_tmp22_ = statn;
				_tmp23_ = (*_tmp22_).rx_speed;
				_tmp24_ = lscale;
				rspeed = _tmp23_ * _tmp24_;
				_tmp25_ = statn;
				_tmp26_ = (*_tmp25_).tx_speed;
				_tmp27_ = lscale;
				tspeed = _tmp26_ * _tmp27_;
				_tmp28_ = rspeed;
				_tmp29_ = tspeed;
				if ((_tmp28_ + _tmp29_) > max_speed) {
					StatusIconIFTransSpeed _tmp30_ = {0};
					status_icon_if_update_scale (self);
					status_icon_if_get_speed (self, max_speed, &_tmp30_);
					*result = _tmp30_;
					_byte_stat_free0 (statn);
					tx_list = (g_free (tx_list), NULL);
					rx_list = (g_free (rx_list), NULL);
					return;
				} else {
					gdouble* _tmp31_;
					gint _tmp31__length1;
					gint _tmp32_;
					gdouble _tmp33_;
					gdouble* _tmp34_;
					gint _tmp34__length1;
					gint _tmp35_;
					gdouble _tmp36_;
					_tmp31_ = rx_list;
					_tmp31__length1 = rx_list_length1;
					_tmp32_ = i;
					_tmp33_ = rspeed;
					_tmp31_[_tmp32_] = _tmp33_;
					_tmp34_ = tx_list;
					_tmp34__length1 = tx_list_length1;
					_tmp35_ = i;
					_tmp36_ = tspeed;
					_tmp34_[_tmp35_] = _tmp36_;
				}
				_byte_stat_free0 (statn);
			}
		}
	}
	_tmp37_ = rx_list;
	_tmp37__length1 = rx_list_length1;
	_tmp38_ = (_tmp37_ != NULL) ? _vala_array_dup1 (_tmp37_, _tmp37__length1) : ((gpointer) _tmp37_);
	_tmp38__length1 = _tmp37__length1;
	_tmp39_ = tx_list;
	_tmp39__length1 = tx_list_length1;
	_tmp40_ = (_tmp39_ != NULL) ? _vala_array_dup2 (_tmp39_, _tmp39__length1) : ((gpointer) _tmp39_);
	_tmp40__length1 = _tmp39__length1;
	memset (&_tmp41_, 0, sizeof (StatusIconIFTransSpeed));
	_tmp41_.rx_list = (g_free (_tmp41_.rx_list), NULL);
	_tmp41_.rx_list = _tmp38_;
	_tmp41_.rx_list_length1 = _tmp38__length1;
	_tmp41_._rx_list_size_ = _tmp41_.rx_list_length1;
	_tmp41_.tx_list = (g_free (_tmp41_.tx_list), NULL);
	_tmp41_.tx_list = _tmp40_;
	_tmp41_.tx_list_length1 = _tmp40__length1;
	_tmp41_._tx_list_size_ = _tmp41_.tx_list_length1;
	ret = _tmp41_;
	*result = ret;
	tx_list = (g_free (tx_list), NULL);
	rx_list = (g_free (rx_list), NULL);
	return;
}


static gint
status_icon_if_color_index_by_speed (StatusIconIF* self,
                                     gdouble current_speed)
{
	gint result = 0;
	gint speed_color_id = 0;
	g_return_val_if_fail (self != NULL, 0);
	speed_color_id = 0;
	{
		gint i = 0;
		guint* _tmp0_;
		gint _tmp0__length1;
		_tmp0_ = self->priv->color_step;
		_tmp0__length1 = self->priv->color_step_length1;
		i = _tmp0__length1 - 1;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				gint _tmp3_;
				guint* _tmp4_;
				gint _tmp4__length1;
				gint _tmp5_;
				guint _tmp6_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ - 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = i;
				if (!(_tmp3_ > 0)) {
					break;
				}
				_tmp4_ = self->priv->color_step;
				_tmp4__length1 = self->priv->color_step_length1;
				_tmp5_ = i;
				_tmp6_ = _tmp4_[_tmp5_];
				if (current_speed >= ((gdouble) _tmp6_)) {
					gint _tmp7_;
					_tmp7_ = i;
					speed_color_id = _tmp7_;
					break;
				}
			}
		}
	}
	result = speed_color_id;
	return result;
}


static gdouble*
_vala_array_dup3 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}


static gdouble*
_vala_array_dup4 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}


gboolean
status_icon_if_update (StatusIconIF* self)
{
	gboolean result = FALSE;
	cairo_t* _tmp0_;
	IFace* _tmp1_;
	gchar* tooltxt = NULL;
	gchar* _tmp2_;
	GtkStatusIcon* _tmp3_;
	const gchar* _tmp4_;
	gint graph_width = 0;
	cairo_surface_t* _tmp5_;
	gint graph_height = 0;
	cairo_surface_t* _tmp6_;
	StatusIconIFTransSpeed ls = {0};
	gint _tmp7_;
	StatusIconIFTransSpeed _tmp8_ = {0};
	gdouble* rx_list = NULL;
	StatusIconIFTransSpeed _tmp9_;
	gdouble* _tmp10_;
	gint _tmp10__length1;
	gdouble* _tmp11_;
	gint _tmp11__length1;
	gint rx_list_length1;
	gint _rx_list_size_;
	gdouble* tx_list = NULL;
	StatusIconIFTransSpeed _tmp12_;
	gdouble* _tmp13_;
	gint _tmp13__length1;
	gdouble* _tmp14_;
	gint _tmp14__length1;
	gint tx_list_length1;
	gint _tx_list_size_;
	gfloat slow_width = 0.0F;
	gint _tmp15_;
	IFace* _tmp16_;
	guint _tmp17_;
	guint xoffset = 0U;
	IFace* _tmp18_;
	guint _tmp19_;
	gdouble* _tmp20_;
	gint _tmp20__length1;
	cairo_t* _tmp21_;
	cairo_t* _tmp22_;
	gint color_id = 0;
	GdkRGBA color = {0};
	cairo_t* _tmp77_;
	GdkPixbuf* pixbuf = NULL;
	cairo_surface_t* _tmp78_;
	gint _tmp79_;
	gint _tmp80_;
	GdkPixbuf* _tmp81_;
	GtkStatusIcon* _tmp82_;
	GdkPixbuf* _tmp83_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->ctx;
	if (_tmp0_ == NULL) {
		result = TRUE;
		return result;
	}
	_tmp1_ = self->iface;
	iface_update (_tmp1_);
	_tmp2_ = status_icon_if_make_tooltip (self);
	tooltxt = _tmp2_;
	_tmp3_ = self->priv->statusicon;
	_tmp4_ = tooltxt;
	gtk_status_icon_set_tooltip_text (_tmp3_, _tmp4_);
	_tmp5_ = self->priv->surface;
	graph_width = cairo_image_surface_get_width (_tmp5_);
	_tmp6_ = self->priv->surface;
	graph_height = cairo_image_surface_get_height (_tmp6_);
	_tmp7_ = graph_height;
	status_icon_if_get_speed (self, (gdouble) _tmp7_, &_tmp8_);
	ls = _tmp8_;
	_tmp9_ = ls;
	_tmp10_ = _tmp9_.rx_list;
	_tmp10__length1 = _tmp9_.rx_list_length1;
	_tmp11_ = (_tmp10_ != NULL) ? _vala_array_dup3 (_tmp10_, _tmp10__length1) : ((gpointer) _tmp10_);
	_tmp11__length1 = _tmp10__length1;
	rx_list = _tmp11_;
	rx_list_length1 = _tmp11__length1;
	_rx_list_size_ = rx_list_length1;
	_tmp12_ = ls;
	_tmp13_ = _tmp12_.tx_list;
	_tmp13__length1 = _tmp12_.tx_list_length1;
	_tmp14_ = (_tmp13_ != NULL) ? _vala_array_dup4 (_tmp13_, _tmp13__length1) : ((gpointer) _tmp13_);
	_tmp14__length1 = _tmp13__length1;
	tx_list = _tmp14_;
	tx_list_length1 = _tmp14__length1;
	_tx_list_size_ = tx_list_length1;
	_tmp15_ = graph_width;
	_tmp16_ = self->iface;
	_tmp17_ = _tmp16_->maxlen;
	slow_width = ((gfloat) _tmp15_) / _tmp17_;
	_tmp18_ = self->iface;
	_tmp19_ = _tmp18_->maxlen;
	_tmp20_ = rx_list;
	_tmp20__length1 = rx_list_length1;
	xoffset = _tmp19_ - _tmp20__length1;
	_tmp21_ = self->priv->ctx;
	cairo_paint (_tmp21_);
	_tmp22_ = self->priv->ctx;
	cairo_save (_tmp22_);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp23_ = FALSE;
			_tmp23_ = TRUE;
			while (TRUE) {
				gint _tmp25_;
				gdouble* _tmp26_;
				gint _tmp26__length1;
				gdouble speed = 0.0;
				gdouble* _tmp27_;
				gint _tmp27__length1;
				gint _tmp28_;
				gdouble _tmp29_;
				gdouble _tmp30_;
				gdouble _tmp31_;
				GdkRGBA* _tmp32_;
				gint _tmp32__length1;
				gint _tmp33_;
				GdkRGBA _tmp34_;
				cairo_t* _tmp35_;
				GdkRGBA _tmp36_;
				gdouble _tmp37_;
				GdkRGBA _tmp38_;
				gdouble _tmp39_;
				GdkRGBA _tmp40_;
				gdouble _tmp41_;
				cairo_t* _tmp42_;
				gfloat _tmp43_;
				gint _tmp44_;
				guint _tmp45_;
				gint _tmp46_;
				gdouble _tmp47_;
				gfloat _tmp48_;
				gdouble _tmp49_;
				cairo_t* _tmp50_;
				if (!_tmp23_) {
					gint _tmp24_;
					_tmp24_ = i;
					i = _tmp24_ + 1;
				}
				_tmp23_ = FALSE;
				_tmp25_ = i;
				_tmp26_ = rx_list;
				_tmp26__length1 = rx_list_length1;
				if (!(_tmp25_ < _tmp26__length1)) {
					break;
				}
				_tmp27_ = rx_list;
				_tmp27__length1 = rx_list_length1;
				_tmp28_ = i;
				_tmp29_ = _tmp27_[_tmp28_];
				speed = _tmp29_;
				_tmp30_ = speed;
				_tmp31_ = self->priv->scale;
				color_id = status_icon_if_color_index_by_speed (self, _tmp30_ / _tmp31_);
				_tmp32_ = self->priv->rx_colors;
				_tmp32__length1 = self->priv->rx_colors_length1;
				_tmp33_ = color_id;
				_tmp34_ = _tmp32_[_tmp33_];
				color = _tmp34_;
				_tmp35_ = self->priv->ctx;
				_tmp36_ = color;
				_tmp37_ = _tmp36_.red;
				_tmp38_ = color;
				_tmp39_ = _tmp38_.green;
				_tmp40_ = color;
				_tmp41_ = _tmp40_.blue;
				cairo_set_source_rgb (_tmp35_, _tmp37_, _tmp39_, _tmp41_);
				_tmp42_ = self->priv->ctx;
				_tmp43_ = slow_width;
				_tmp44_ = i;
				_tmp45_ = xoffset;
				_tmp46_ = graph_height;
				_tmp47_ = speed;
				_tmp48_ = slow_width;
				_tmp49_ = speed;
				cairo_rectangle (_tmp42_, (gdouble) (_tmp43_ * (_tmp44_ + _tmp45_)), _tmp46_ - _tmp47_, (gdouble) _tmp48_, _tmp49_);
				_tmp50_ = self->priv->ctx;
				cairo_fill (_tmp50_);
			}
		}
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp51_ = FALSE;
			_tmp51_ = TRUE;
			while (TRUE) {
				gint _tmp53_;
				gdouble* _tmp54_;
				gint _tmp54__length1;
				gdouble speed = 0.0;
				gdouble* _tmp55_;
				gint _tmp55__length1;
				gint _tmp56_;
				gdouble _tmp57_;
				gdouble _tmp58_;
				gdouble _tmp59_;
				GdkRGBA* _tmp60_;
				gint _tmp60__length1;
				gint _tmp61_;
				GdkRGBA _tmp62_;
				cairo_t* _tmp63_;
				GdkRGBA _tmp64_;
				gdouble _tmp65_;
				GdkRGBA _tmp66_;
				gdouble _tmp67_;
				GdkRGBA _tmp68_;
				gdouble _tmp69_;
				cairo_t* _tmp70_;
				gfloat _tmp71_;
				gint _tmp72_;
				guint _tmp73_;
				gfloat _tmp74_;
				gdouble _tmp75_;
				cairo_t* _tmp76_;
				if (!_tmp51_) {
					gint _tmp52_;
					_tmp52_ = i;
					i = _tmp52_ + 1;
				}
				_tmp51_ = FALSE;
				_tmp53_ = i;
				_tmp54_ = tx_list;
				_tmp54__length1 = tx_list_length1;
				if (!(_tmp53_ < _tmp54__length1)) {
					break;
				}
				_tmp55_ = tx_list;
				_tmp55__length1 = tx_list_length1;
				_tmp56_ = i;
				_tmp57_ = _tmp55_[_tmp56_];
				speed = _tmp57_;
				_tmp58_ = speed;
				_tmp59_ = self->priv->scale;
				color_id = status_icon_if_color_index_by_speed (self, _tmp58_ / _tmp59_);
				_tmp60_ = self->priv->tx_colors;
				_tmp60__length1 = self->priv->tx_colors_length1;
				_tmp61_ = color_id;
				_tmp62_ = _tmp60_[_tmp61_];
				color = _tmp62_;
				_tmp63_ = self->priv->ctx;
				_tmp64_ = color;
				_tmp65_ = _tmp64_.red;
				_tmp66_ = color;
				_tmp67_ = _tmp66_.green;
				_tmp68_ = color;
				_tmp69_ = _tmp68_.blue;
				cairo_set_source_rgb (_tmp63_, _tmp65_, _tmp67_, _tmp69_);
				_tmp70_ = self->priv->ctx;
				_tmp71_ = slow_width;
				_tmp72_ = i;
				_tmp73_ = xoffset;
				_tmp74_ = slow_width;
				_tmp75_ = speed;
				cairo_rectangle (_tmp70_, (gdouble) (_tmp71_ * (_tmp72_ + _tmp73_)), (gdouble) 0, (gdouble) _tmp74_, _tmp75_);
				_tmp76_ = self->priv->ctx;
				cairo_fill (_tmp76_);
			}
		}
	}
	_tmp77_ = self->priv->ctx;
	cairo_restore (_tmp77_);
	_tmp78_ = self->priv->surface;
	_tmp79_ = graph_width;
	_tmp80_ = graph_height;
	_tmp81_ = gdk_pixbuf_get_from_surface (_tmp78_, 0, 0, _tmp79_, _tmp80_);
	pixbuf = _tmp81_;
	_tmp82_ = self->priv->statusicon;
	_tmp83_ = pixbuf;
	gtk_status_icon_set_from_pixbuf (_tmp82_, _tmp83_);
	result = TRUE;
	_g_object_unref0 (pixbuf);
	tx_list = (g_free (tx_list), NULL);
	rx_list = (g_free (rx_list), NULL);
	status_icon_if_trans_speed_destroy (&ls);
	_g_free0 (tooltxt);
	return result;
}


static gboolean
_status_icon_if_update_gsource_func (gpointer self)
{
	gboolean result;
	result = status_icon_if_update ((StatusIconIF*) self);
	return result;
}


void
status_icon_if_start_timers (StatusIconIF* self)
{
	guint _tmp0_;
	guint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->update_timeout;
	self->priv->update_id = g_timeout_add_full (G_PRIORITY_DEFAULT, _tmp0_, _status_icon_if_update_gsource_func, g_object_ref (self), g_object_unref);
	_tmp1_ = self->update_scale_timeout;
	self->priv->update_scale_id = g_timeout_add_full (G_PRIORITY_DEFAULT, _tmp1_, _status_icon_if_update_scale_gsource_func, g_object_ref (self), g_object_unref);
}


void
status_icon_if_on_quit (StatusIconIF* self,
                        GtkAction* act)
{
	Application* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (act != NULL);
	_tmp0_ = self->priv->app;
	application_quit (_tmp0_);
}


void
status_icon_if_on_destroy (StatusIconIF* self)
{
	guint _tmp0_;
	guint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->update_id;
	g_source_remove (_tmp0_);
	_tmp1_ = self->priv->update_scale_id;
	g_source_remove (_tmp1_);
}


static gdouble*
_vala_array_dup5 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}


static gdouble*
_vala_array_dup6 (gdouble* self,
                  int length)
{
	return g_memdup (self, length * sizeof (gdouble));
}


static void
status_icon_if_trans_speed_copy (const StatusIconIFTransSpeed* self,
                                 StatusIconIFTransSpeed* dest)
{
	gdouble* _tmp0_;
	gint _tmp0__length1;
	gdouble* _tmp1_;
	gint _tmp1__length1;
	gdouble* _tmp2_;
	gint _tmp2__length1;
	gdouble* _tmp3_;
	gint _tmp3__length1;
	_tmp0_ = (*self).rx_list;
	_tmp0__length1 = (*self).rx_list_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup5 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	(*dest).rx_list = (g_free ((*dest).rx_list), NULL);
	(*dest).rx_list = _tmp1_;
	(*dest).rx_list_length1 = _tmp1__length1;
	(*dest)._rx_list_size_ = (*dest).rx_list_length1;
	_tmp2_ = (*self).tx_list;
	_tmp2__length1 = (*self).tx_list_length1;
	_tmp3_ = (_tmp2_ != NULL) ? _vala_array_dup6 (_tmp2_, _tmp2__length1) : ((gpointer) _tmp2_);
	_tmp3__length1 = _tmp2__length1;
	(*dest).tx_list = (g_free ((*dest).tx_list), NULL);
	(*dest).tx_list = _tmp3_;
	(*dest).tx_list_length1 = _tmp3__length1;
	(*dest)._tx_list_size_ = (*dest).tx_list_length1;
}


static void
status_icon_if_trans_speed_destroy (StatusIconIFTransSpeed* self)
{
	(*self).rx_list = (g_free ((*self).rx_list), NULL);
	(*self).tx_list = (g_free ((*self).tx_list), NULL);
}


static StatusIconIFTransSpeed*
status_icon_if_trans_speed_dup (const StatusIconIFTransSpeed* self)
{
	StatusIconIFTransSpeed* dup;
	dup = g_new0 (StatusIconIFTransSpeed, 1);
	status_icon_if_trans_speed_copy (self, dup);
	return dup;
}


static void
status_icon_if_trans_speed_free (StatusIconIFTransSpeed* self)
{
	status_icon_if_trans_speed_destroy (self);
	g_free (self);
}


static GType
status_icon_if_trans_speed_get_type (void)
{
	static volatile gsize status_icon_if_trans_speed_type_id__volatile = 0;
	if (g_once_init_enter (&status_icon_if_trans_speed_type_id__volatile)) {
		GType status_icon_if_trans_speed_type_id;
		status_icon_if_trans_speed_type_id = g_boxed_type_register_static ("StatusIconIFTransSpeed", (GBoxedCopyFunc) status_icon_if_trans_speed_dup, (GBoxedFreeFunc) status_icon_if_trans_speed_free);
		g_once_init_leave (&status_icon_if_trans_speed_type_id__volatile, status_icon_if_trans_speed_type_id);
	}
	return status_icon_if_trans_speed_type_id__volatile;
}


static void
status_icon_if_class_init (StatusIconIFClass * klass)
{
	status_icon_if_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (StatusIconIFPrivate));
	G_OBJECT_CLASS (klass)->finalize = status_icon_if_finalize;
}


static void
status_icon_if_instance_init (StatusIconIF * self)
{
	guint* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar** _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar** _tmp12_;
	GdkRGBA* _tmp13_;
	GdkRGBA* _tmp14_;
	self->priv = STATUS_ICON_IF_GET_PRIVATE (self);
	self->priv->ctx = NULL;
	self->priv->scale = -1.0;
	self->priv->update_id = (guint) -1;
	self->priv->update_scale_id = (guint) -1;
	self->priv->margin = 1;
	self->portion = 0.8f;
	self->portion_low = 0.3f;
	self->rate_low = 1024.0f;
	self->update_timeout = (guint) 1000;
	_tmp0_ = g_new0 (guint, 5);
	_tmp0_[0] = (guint) 0x0;
	_tmp0_[1] = (guint) 0x400;
	_tmp0_[2] = (guint) 0x2800;
	_tmp0_[3] = (guint) 0x100000;
	_tmp0_[4] = (guint) 0x990000;
	self->priv->color_step = _tmp0_;
	self->priv->color_step_length1 = 5;
	self->priv->_color_step_size_ = self->priv->color_step_length1;
	_tmp1_ = g_strdup ("#0ea5fd");
	_tmp2_ = g_strdup ("#03fc83");
	_tmp3_ = g_strdup ("#c1fa07");
	_tmp4_ = g_strdup ("#f908fa");
	_tmp5_ = g_strdup ("#fc0527");
	_tmp6_ = g_new0 (gchar*, 5 + 1);
	_tmp6_[0] = _tmp1_;
	_tmp6_[1] = _tmp2_;
	_tmp6_[2] = _tmp3_;
	_tmp6_[3] = _tmp4_;
	_tmp6_[4] = _tmp5_;
	self->priv->rx_color_strings = _tmp6_;
	self->priv->rx_color_strings_length1 = 5;
	self->priv->_rx_color_strings_size_ = self->priv->rx_color_strings_length1;
	_tmp7_ = g_strdup ("#057cc0");
	_tmp8_ = g_strdup ("#05c065");
	_tmp9_ = g_strdup ("#99bf1c");
	_tmp10_ = g_strdup ("#af03b0");
	_tmp11_ = g_strdup ("#c43b4e");
	_tmp12_ = g_new0 (gchar*, 5 + 1);
	_tmp12_[0] = _tmp7_;
	_tmp12_[1] = _tmp8_;
	_tmp12_[2] = _tmp9_;
	_tmp12_[3] = _tmp10_;
	_tmp12_[4] = _tmp11_;
	self->priv->tx_color_strings = _tmp12_;
	self->priv->tx_color_strings_length1 = 5;
	self->priv->_tx_color_strings_size_ = self->priv->tx_color_strings_length1;
	_tmp13_ = g_new0 (GdkRGBA, 0);
	self->priv->rx_colors = _tmp13_;
	self->priv->rx_colors_length1 = 0;
	self->priv->_rx_colors_size_ = self->priv->rx_colors_length1;
	_tmp14_ = g_new0 (GdkRGBA, 0);
	self->priv->tx_colors = _tmp14_;
	self->priv->tx_colors_length1 = 0;
	self->priv->_tx_colors_size_ = self->priv->tx_colors_length1;
}


static void
status_icon_if_finalize (GObject * obj)
{
	StatusIconIF * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_STATUS_ICON_IF, StatusIconIF);
	_g_object_unref0 (self->priv->app);
	_cairo_destroy0 (self->priv->ctx);
	_cairo_surface_destroy0 (self->priv->surface);
	_g_object_unref0 (self->priv->statusicon);
	_g_object_unref0 (self->priv->menu);
	_g_object_unref0 (self->iface);
	self->priv->color_step = (g_free (self->priv->color_step), NULL);
	self->priv->rx_color_strings = (_vala_array_free (self->priv->rx_color_strings, self->priv->rx_color_strings_length1, (GDestroyNotify) g_free), NULL);
	self->priv->tx_color_strings = (_vala_array_free (self->priv->tx_color_strings, self->priv->tx_color_strings_length1, (GDestroyNotify) g_free), NULL);
	self->priv->rx_colors = (g_free (self->priv->rx_colors), NULL);
	self->priv->tx_colors = (g_free (self->priv->tx_colors), NULL);
	G_OBJECT_CLASS (status_icon_if_parent_class)->finalize (obj);
}


GType
status_icon_if_get_type (void)
{
	static volatile gsize status_icon_if_type_id__volatile = 0;
	if (g_once_init_enter (&status_icon_if_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (StatusIconIFClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) status_icon_if_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (StatusIconIF), 0, (GInstanceInitFunc) status_icon_if_instance_init, NULL };
		GType status_icon_if_type_id;
		status_icon_if_type_id = g_type_register_static (G_TYPE_OBJECT, "StatusIconIF", &g_define_type_info, 0);
		g_once_init_leave (&status_icon_if_type_id__volatile, status_icon_if_type_id);
	}
	return status_icon_if_type_id__volatile;
}


static gint
__lambda4_ (Application* self,
            const gchar* a,
            const gchar* b)
{
	gint result = 0;
	GCompareFunc _tmp0_;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = ((GCompareFunc) g_strcmp0);
	result = _tmp0_ (a, b);
	return result;
}


static gint
___lambda4__gcompare_data_func (gconstpointer a,
                                gconstpointer b,
                                gpointer self)
{
	gint result;
	result = __lambda4_ ((Application*) self, (const gchar*) a, (const gchar*) b);
	return result;
}


static void
_g_object_unref_gdestroy_notify (void* data)
{
	g_object_unref (data);
}


static Application*
application_construct (GType object_type)
{
	Application * self = NULL;
	GDestroyNotify _tmp0_;
	GTree* _tmp1_;
	self = (Application*) g_object_new (object_type, NULL);
	_tmp0_ = g_free;
	_tmp1_ = g_tree_new_full (___lambda4__gcompare_data_func, self, _tmp0_, _g_object_unref_gdestroy_notify);
	_g_tree_unref0 (self->priv->iface_map);
	self->priv->iface_map = _tmp1_;
	return self;
}


static Application*
application_new (void)
{
	return application_construct (TYPE_APPLICATION);
}


static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		Application* self;
		self = _data1_->self;
		_data1_->key2remove = (_vala_array_free (_data1_->key2remove, _data1_->key2remove_length1, (GDestroyNotify) g_free), NULL);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void
_vala_array_add3 (gchar** * array,
                  int* length,
                  int* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gboolean
__lambda5_ (Block1Data* _data1_,
            const gchar* k,
            StatusIconIF* v)
{
	Application* self;
	gboolean result = FALSE;
	StatusIconIF* v1 = NULL;
	StatusIconIF* _tmp0_;
	StatusIconIF* _tmp1_;
	IFace* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	self = _data1_->self;
	g_return_val_if_fail (k != NULL, FALSE);
	g_return_val_if_fail (v != NULL, FALSE);
	_tmp0_ = _g_object_ref0 (IS_STATUS_ICON_IF (v) ? ((StatusIconIF*) v) : NULL);
	v1 = _tmp0_;
	_tmp1_ = v1;
	_tmp2_ = _tmp1_->iface;
	_tmp3_ = iface_get_isup (_tmp2_);
	_tmp4_ = _tmp3_;
	if (!_tmp4_) {
		gchar** _tmp5_;
		gint _tmp5__length1;
		gchar* _tmp6_;
		_tmp5_ = _data1_->key2remove;
		_tmp5__length1 = _data1_->key2remove_length1;
		_tmp6_ = g_strdup ((const gchar*) k);
		_vala_array_add3 (&_data1_->key2remove, &_data1_->key2remove_length1, &_data1_->_key2remove_size_, _tmp6_);
	}
	result = FALSE;
	_g_object_unref0 (v1);
	return result;
}


static gboolean
___lambda5__gtraverse_func (gconstpointer key,
                            gconstpointer value,
                            gpointer self)
{
	gboolean result;
	result = __lambda5_ (self, (const gchar*) key, (StatusIconIF*) value);
	return result;
}


static gboolean
application_update_iface (Application* self)
{
	gboolean result = FALSE;
	Block1Data* _data1_;
	gchar** _tmp34_;
	GTree* _tmp35_;
	gchar** _tmp36_;
	gint _tmp36__length1;
	GError* _inner_error0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	{
		GFile* root = NULL;
		GFile* _tmp0_;
		GFileEnumerator* root_enum = NULL;
		GFile* _tmp1_;
		GFileEnumerator* _tmp2_;
		GFileInfo* file_info = NULL;
		_tmp0_ = g_file_new_for_path (SYS_NET_PATH);
		root = _tmp0_;
		_tmp1_ = root;
		_tmp2_ = g_file_enumerate_children (_tmp1_, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error0_);
		root_enum = _tmp2_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (root);
			goto __catch3_g_error;
		}
		while (TRUE) {
			GFileInfo* _tmp3_ = NULL;
			GFileEnumerator* _tmp4_;
			GFileInfo* _tmp5_;
			GFileInfo* _tmp6_;
			GFileInfo* _tmp7_;
			gchar* fid = NULL;
			GFileInfo* _tmp8_;
			const gchar* _tmp9_;
			gchar* _tmp10_;
			gboolean _tmp11_ = FALSE;
			const gchar* _tmp12_;
			_tmp4_ = root_enum;
			_tmp5_ = g_file_enumerator_next_file (_tmp4_, NULL, &_inner_error0_);
			_tmp3_ = _tmp5_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_object_unref0 (file_info);
				_g_object_unref0 (root_enum);
				_g_object_unref0 (root);
				goto __catch3_g_error;
			}
			_tmp6_ = _tmp3_;
			_tmp3_ = NULL;
			_g_object_unref0 (file_info);
			file_info = _tmp6_;
			_tmp7_ = file_info;
			if (!(_tmp7_ != NULL)) {
				_g_object_unref0 (_tmp3_);
				break;
			}
			_tmp8_ = file_info;
			_tmp9_ = g_file_info_get_name (_tmp8_);
			_tmp10_ = g_strdup (_tmp9_);
			fid = _tmp10_;
			_tmp12_ = fid;
			if (g_strcmp0 (_tmp12_, "lo") != 0) {
				GTree* _tmp13_;
				const gchar* _tmp14_;
				gconstpointer _tmp15_;
				_tmp13_ = self->priv->iface_map;
				_tmp14_ = fid;
				_tmp15_ = g_tree_lookup (_tmp13_, _tmp14_);
				_tmp11_ = ((StatusIconIF*) _tmp15_) == NULL;
			} else {
				_tmp11_ = FALSE;
			}
			if (_tmp11_) {
				IFace* iface = NULL;
				const gchar* _tmp16_;
				IFace* _tmp17_;
				IFace* _tmp18_;
				gboolean _tmp19_;
				gboolean _tmp20_;
				_tmp16_ = fid;
				_tmp17_ = iface_new (_tmp16_);
				iface = _tmp17_;
				_tmp18_ = iface;
				_tmp19_ = iface_get_isup (_tmp18_);
				_tmp20_ = _tmp19_;
				if (_tmp20_) {
					StatusIconIF* v = NULL;
					IFace* _tmp21_;
					StatusIconIF* _tmp22_;
					StatusIconIF* _tmp23_;
					StatusIconIF* _tmp24_;
					GTree* _tmp25_;
					const gchar* _tmp26_;
					gchar* _tmp27_;
					StatusIconIF* _tmp28_;
					StatusIconIF* _tmp29_;
					_tmp21_ = iface;
					_tmp22_ = status_icon_if_new (self, _tmp21_);
					v = _tmp22_;
					_tmp23_ = v;
					status_icon_if_start_timers (_tmp23_);
					_tmp24_ = v;
					status_icon_if_update (_tmp24_);
					_tmp25_ = self->priv->iface_map;
					_tmp26_ = fid;
					_tmp27_ = g_strdup (_tmp26_);
					_tmp28_ = v;
					_tmp29_ = _g_object_ref0 (_tmp28_);
					g_tree_insert (_tmp25_, _tmp27_, _tmp29_);
					_g_object_unref0 (v);
				}
				_g_object_unref0 (iface);
			}
			_g_free0 (fid);
			_g_object_unref0 (_tmp3_);
		}
		_g_object_unref0 (file_info);
		_g_object_unref0 (root_enum);
		_g_object_unref0 (root);
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		FILE* _tmp30_;
		GError* _tmp31_;
		const gchar* _tmp32_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp30_ = stderr;
		_tmp31_ = e;
		_tmp32_ = _tmp31_->message;
		fprintf (_tmp30_, "Error: %s\n", _tmp32_);
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp33_ = FALSE;
		block1_data_unref (_data1_);
		_data1_ = NULL;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp33_;
	}
	_tmp34_ = g_new0 (gchar*, 0 + 1);
	_data1_->key2remove = _tmp34_;
	_data1_->key2remove_length1 = 0;
	_data1_->_key2remove_size_ = _data1_->key2remove_length1;
	_tmp35_ = self->priv->iface_map;
	g_tree_foreach (_tmp35_, ___lambda5__gtraverse_func, _data1_);
	_tmp36_ = _data1_->key2remove;
	_tmp36__length1 = _data1_->key2remove_length1;
	{
		gchar** k_collection = NULL;
		gint k_collection_length1 = 0;
		gint _k_collection_size_ = 0;
		gint k_it = 0;
		k_collection = _tmp36_;
		k_collection_length1 = _tmp36__length1;
		for (k_it = 0; k_it < k_collection_length1; k_it = k_it + 1) {
			gchar* _tmp37_;
			gchar* k = NULL;
			_tmp37_ = g_strdup (k_collection[k_it]);
			k = _tmp37_;
			{
				GTree* _tmp38_;
				const gchar* _tmp39_;
				gconstpointer _tmp40_;
				GTree* _tmp41_;
				const gchar* _tmp42_;
				_tmp38_ = self->priv->iface_map;
				_tmp39_ = k;
				_tmp40_ = g_tree_lookup (_tmp38_, _tmp39_);
				status_icon_if_on_destroy ((StatusIconIF*) _tmp40_);
				_tmp41_ = self->priv->iface_map;
				_tmp42_ = k;
				g_tree_remove (_tmp41_, _tmp42_);
				_g_free0 (k);
			}
		}
	}
	result = TRUE;
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


static void
__lambda6_ (Application* self,
            GtkDialog* a,
            gint b)
{
	gulong _tmp0_;
	g_return_if_fail (a != NULL);
	_tmp0_ = self->priv->about_response_id;
	g_signal_handler_disconnect ((GObject*) a, _tmp0_);
	gtk_widget_destroy ((GtkWidget*) a);
}


static void
___lambda6__gtk_dialog_response (GtkDialog* _sender,
                                 gint response_id,
                                 gpointer self)
{
	__lambda6_ ((Application*) self, _sender, response_id);
}


void
application_on_about_dialog_show (Application* self,
                                  GtkAction* act)
{
	GtkAboutDialog* ad = NULL;
	GtkAboutDialog* _tmp0_;
	gulong _tmp1_;
	static const gchar* authors[5] = {"Mozbugbox", "", "", "", "bits per second support added by whorfin"};
	g_return_if_fail (self != NULL);
	g_return_if_fail (act != NULL);
	_tmp0_ = (GtkAboutDialog*) gtk_about_dialog_new ();
	g_object_ref_sink (_tmp0_);
	ad = _tmp0_;
	_tmp1_ = g_signal_connect_object ((GtkDialog*) ad, "response", (GCallback) ___lambda6__gtk_dialog_response, self, 0);
	self->priv->about_response_id = _tmp1_;
	gtk_about_dialog_set_program_name (ad, PACKAGE_NAME);
	gtk_about_dialog_set_version (ad, HGVERSION);
	gtk_about_dialog_set_copyright (ad, "Mozbugbox 2011-2013");
	gtk_about_dialog_set_license_type (ad, GTK_LICENSE_GPL_3_0);
	gtk_about_dialog_set_website (ad, PACKAGE_URL);
	gtk_about_dialog_set_website_label (ad, "Byte On Panel Wiki");
	gtk_about_dialog_set_authors (ad, authors);
	gtk_window_present ((GtkWindow*) ad);
	_g_object_unref0 (ad);
}


static gboolean
_application_update_iface_gsource_func (gpointer self)
{
	gboolean result;
	result = application_update_iface ((Application*) self);
	return result;
}


void
application_start (Application* self)
{
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	application_update_iface (self);
	_tmp0_ = self->priv->iface_update_timeout;
	g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, _tmp0_, _application_update_iface_gsource_func, g_object_ref (self), g_object_unref);
	gtk_main ();
}


void
application_quit (Application* self)
{
	g_return_if_fail (self != NULL);
	gtk_main_quit ();
}


gint
application_main (gchar** args,
                  int args_length1)
{
	gint result = 0;
	Application* app = NULL;
	Application* _tmp0_;
	gtk_init (&args_length1, &args);
	_tmp0_ = application_new ();
	app = _tmp0_;
	application_start (app);
	result = 0;
	_g_object_unref0 (app);
	return result;
}


int
main (int argc,
      char ** argv)
{
	return application_main (argv, argc);
}


static void
application_class_init (ApplicationClass * klass)
{
	application_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ApplicationPrivate));
	G_OBJECT_CLASS (klass)->finalize = application_finalize;
}


static void
application_instance_init (Application * self)
{
	self->priv = APPLICATION_GET_PRIVATE (self);
	self->priv->iface_update_timeout = (guint) 5;
}


static void
application_finalize (GObject * obj)
{
	Application * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_APPLICATION, Application);
	_g_tree_unref0 (self->priv->iface_map);
	G_OBJECT_CLASS (application_parent_class)->finalize (obj);
}


GType
application_get_type (void)
{
	static volatile gsize application_type_id__volatile = 0;
	if (g_once_init_enter (&application_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ApplicationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) application_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Application), 0, (GInstanceInitFunc) application_instance_init, NULL };
		GType application_type_id;
		application_type_id = g_type_register_static (G_TYPE_OBJECT, "Application", &g_define_type_info, 0);
		g_once_init_leave (&application_type_id__volatile, application_type_id);
	}
	return application_type_id__volatile;
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



